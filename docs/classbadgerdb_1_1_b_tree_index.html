<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BadgerDB: badgerdb::BTreeIndex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BadgerDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebadgerdb.html">badgerdb</a></li><li class="navelem"><a class="el" href="classbadgerdb_1_1_b_tree_index.html">BTreeIndex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbadgerdb_1_1_b_tree_index-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">badgerdb::BTreeIndex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation....">BTreeIndex</a> class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time.  
 <a href="classbadgerdb_1_1_b_tree_index.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="btree_8h_source.html">btree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4867de84c5392d9df9cb54438dd35d38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a4867de84c5392d9df9cb54438dd35d38">BTreeIndex</a> (const std::string &amp;relationName, std::string &amp;outIndexName, <a class="el" href="classbadgerdb_1_1_buf_mgr.html">BufMgr</a> *bufMgrIn, const int attrByteOffset, const <a class="el" href="namespacebadgerdb.html#a9dc9c8fe64ff894720886ba4b9f81f4b">Datatype</a> attrType)</td></tr>
<tr class="separator:a4867de84c5392d9df9cb54438dd35d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a15bba5c82d90e316dd6a1a10cc52a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#ad6a15bba5c82d90e316dd6a1a10cc52a">~BTreeIndex</a> ()</td></tr>
<tr class="separator:ad6a15bba5c82d90e316dd6a1a10cc52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a051c8c03a5cc0ca9451bdd56ddb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a70a051c8c03a5cc0ca9451bdd56ddb65">insertEntry</a> (const void *key, const <a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> rid)</td></tr>
<tr class="separator:a70a051c8c03a5cc0ca9451bdd56ddb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e41d11eeaf3d28fc9748edec50ac98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a13e41d11eeaf3d28fc9748edec50ac98">startScan</a> (const void *lowVal, const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a> lowOp, const void *highVal, const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a> highOp)</td></tr>
<tr class="separator:a13e41d11eeaf3d28fc9748edec50ac98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae874d8a55fa110ba2b76b4180ac9d2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#ae874d8a55fa110ba2b76b4180ac9d2ad">scanNext</a> (<a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> &amp;outRid)</td></tr>
<tr class="separator:ae874d8a55fa110ba2b76b4180ac9d2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd0537ea88ef28eaea8c8fd75e5a1bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbadgerdb_1_1_b_tree_index.html#a7fd0537ea88ef28eaea8c8fd75e5a1bb">endScan</a> ()</td></tr>
<tr class="separator:a7fd0537ea88ef28eaea8c8fd75e5a1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation....">BTreeIndex</a> class. It implements a B+ Tree index on a single attribute of a relation. This index supports only one scan at a time. </p>

<p class="definition">Definition at line <a class="el" href="btree_8h_source.html#l00187">187</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4867de84c5392d9df9cb54438dd35d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4867de84c5392d9df9cb54438dd35d38">&#9670;&nbsp;</a></span>BTreeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">badgerdb::BTreeIndex::BTreeIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>relationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outIndexName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbadgerdb_1_1_buf_mgr.html">BufMgr</a> *&#160;</td>
          <td class="paramname"><em>bufMgrIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>attrByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#a9dc9c8fe64ff894720886ba4b9f81f4b">Datatype</a>&#160;</td>
          <td class="paramname"><em>attrType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation....">BTreeIndex</a> Constructor. Check to see if the corresponding index file exists. If so, open the file. If not, create it and insert entries for every tuple in the base relation using <a class="el" href="classbadgerdb_1_1_file_scan.html" title="This class is used to sequentially scan records in a relation.">FileScan</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relationName</td><td>Name of file. </td></tr>
    <tr><td class="paramname">outIndexName</td><td>Return the name of index file. </td></tr>
    <tr><td class="paramname">bufMgrIn</td><td>Buffer Manager Instance </td></tr>
    <tr><td class="paramname">attrByteOffset</td><td>Offset of attribute, over which index is to be built, in the record </td></tr>
    <tr><td class="paramname">attrType</td><td>Datatype of attribute over which index is built </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_index_info_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist.">BadIndexInfoException</a></td><td>If the index file already exists for the corresponding attribute, but values in metapage(relationName, attribute byte offset, attribute type etc.) do not match with values received through constructor parameters. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00029">29</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  bufMgr = bufMgrIn;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  attributeType = attrType; <span class="comment">// should just be INTEGER</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  this.attrByteOffset = attrByteOffset;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  std::ostringstream idxStr;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  idxStr &lt;&lt; relationName &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; attrByteOffset;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  std::string indexName = idxStr.str(); <span class="comment">// indexName is the name of the index file</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  outIndexName = indexName;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160; </div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="comment">// @TODO: initialize the BTree data structure</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="comment">// if indexName exists, then the file is opened. Else, a new index file is created.</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    BlobFile bf = BlobFile.create(indexName); </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  }</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="keywordflow">catch</span>(FileExistsException exists) {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Index file &quot;</span> &lt;&lt; indexName &lt;&lt; <span class="stringliteral">&quot; already exists!&quot;</span>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="comment">// the constructor should scan relationName and insert entries</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="comment">// for all of the tuples in the relation into the index</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  FileScan scan(relationName, bufMgr);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="keywordflow">try</span> {</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    RecordId nextRec;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      scan.scanNext(nextRec);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      <span class="comment">// --- The following is taken from main.cpp:121 ---</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      <span class="comment">// Assuming RECORD.i is our key, lets extract the key, which we know is </span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <span class="comment">// INTEGER and whose byte offset is also know inside the record. </span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      std::string recordStr = scan.getRecord();</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">char</span> *record = recordStr.c_str();</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;      <span class="keywordtype">int</span> key = *((<span class="keywordtype">int</span> *)(record + attrByteOffset))); <span class="comment">// offsetof (attributeType, i)));</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      <a class="code" href="classbadgerdb_1_1_b_tree_index.html#a70a051c8c03a5cc0ca9451bdd56ddb65">insertEntry</a>(key, nextRec);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    }</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  }</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keywordflow">catch</span>(EndOfFileException end) {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Initial file scan of &quot;</span> &lt;&lt; indexName &lt;&lt; <span class="stringliteral">&quot; finished.&quot;</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6a15bba5c82d90e316dd6a1a10cc52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a15bba5c82d90e316dd6a1a10cc52a">&#9670;&nbsp;</a></span>~BTreeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">badgerdb::BTreeIndex::~BTreeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classbadgerdb_1_1_b_tree_index.html" title="BTreeIndex class. It implements a B+ Tree index on a single attribute of a relation....">BTreeIndex</a> Destructor. End any initialized scan, flush index file, after unpinning any pinned pages, from the buffer manager and delete file instance thereby closing the index file. Destructor should not throw any exceptions. All exceptions should be caught in here itself. </p>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00088">88</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;{</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">  The destructor. Perform any cleanup that may be necessary, including clearing up</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">  any state variables, unpinning any B+ Tree pages that are pinned, and flushing the</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">  index file (by calling bufMgr-&gt;flushFile()). Note that this method does not</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">  delete the index file! But, deletion of the file object is required, which will call the</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">  destructor of File class causing the index file to be closed.</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; </div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// clearing up any state variables</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  </div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160; </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// unpinning any B+ tree pages that are pinned</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <a class="code" href="classbadgerdb_1_1_b_tree_index.html#a13e41d11eeaf3d28fc9748edec50ac98">startScan</a>();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="comment">// flushing the index</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  bufMgr-&gt;<a class="code" href="classbadgerdb_1_1_buf_mgr.html#acc61d1985720411ebb76e70f702827d3">flushFile</a>();</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fd0537ea88ef28eaea8c8fd75e5a1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd0537ea88ef28eaea8c8fd75e5a1bb">&#9670;&nbsp;</a></span>endScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void badgerdb::BTreeIndex::endScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminate the current scan. Unpin any pinned pages. Reset scan specific variables. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_scan_not_initialized_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist.">ScanNotInitializedException</a></td><td>If no scan has been initialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00167">167</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160; </div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a70a051c8c03a5cc0ca9451bdd56ddb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a051c8c03a5cc0ca9451bdd56ddb65">&#9670;&nbsp;</a></span>insertEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void badgerdb::BTreeIndex::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a>&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a new entry using the pair &lt;value,rid&gt;. Start from root to recursively find out the leaf to insert the entry in. The insertion may cause splitting of leaf node. This splitting will require addition of new leaf page number entry into the parent non-leaf, which may in-turn get split. This may continue all the way upto the root causing the root to get split. If root gets split, metapage needs to be changed accordingly. Make sure to unpin pages as soon as you can. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to insert, pointer to integer/double/char string </td></tr>
    <tr><td class="paramname">rid</td><td>Record ID of a record whose entry is getting inserted into the index. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00113">113</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;{</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">  Start from root and recursively search for which leaf, key belongs to</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">  If leaf is full then split leaf, update parent non-leaf, and if root needs splitting then update metadata</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  NonLeafNodeInt nonleaf;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  nonleaf.level = 0</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  nonleaf.keyArray </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keywordflow">if</span> (key &gt; IndexMetaInfo.rootPageNo) {</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <a class="code" href="classbadgerdb_1_1_b_tree_index.html#a70a051c8c03a5cc0ca9451bdd56ddb65">insertEntry</a>()</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae874d8a55fa110ba2b76b4180ac9d2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae874d8a55fa110ba2b76b4180ac9d2ad">&#9670;&nbsp;</a></span>scanNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void badgerdb::BTreeIndex::scanNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbadgerdb_1_1_record_id.html">RecordId</a> &amp;&#160;</td>
          <td class="paramname"><em>outRid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch the record id of the next index entry that matches the scan. Return the next record from current page being scanned. If current page has been scanned to its entirety, move on to the right sibling of current page, if any exists, to start scanning that page. Make sure to unpin any pages that are no longer required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outRid</td><td><a class="el" href="structbadgerdb_1_1_record_id.html" title="Identifier for a record in a page.">RecordId</a> of next record found that satisfies the scan criteria returned in this </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_scan_not_initialized_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist.">ScanNotInitializedException</a></td><td>If no scan has been initialized. </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_index_scan_completed_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist.">IndexScanCompletedException</a></td><td>If no more records, satisfying the scan criteria, are left to be scanned. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00152">152</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;{</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment">  This method is used to begin a “filtered scan” of the index. For example, if the</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment">  method is called using arguments (1,GT,100,LTE), then the scan should seek all</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">  entries greater than 1 and less than or equal to 100.</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160; </div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  </div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13e41d11eeaf3d28fc9748edec50ac98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e41d11eeaf3d28fc9748edec50ac98">&#9670;&nbsp;</a></span>startScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void badgerdb::BTreeIndex::startScan </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>lowVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a>&#160;</td>
          <td class="paramname"><em>lowOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>highVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebadgerdb.html#aad50f9c7a9ef0cbcfe0b025a7aa5cb28">Operator</a>&#160;</td>
          <td class="paramname"><em>highOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin a filtered scan of the index. For instance, if the method is called using ("a",GT,"d",LTE) then we should seek all entries with a value greater than "a" and less than or equal to "d". If another scan is already executing, that needs to be ended here. Set up all the variables for scan. Start from root to find out the leaf page that contains the first RecordID that satisfies the scan parameters. Keep that page pinned in the buffer pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lowVal</td><td>Low value of range, pointer to integer / double / char string </td></tr>
    <tr><td class="paramname">lowOp</td><td>Low operator (GT/GTE) </td></tr>
    <tr><td class="paramname">highVal</td><td>High value of range, pointer to integer / double / char string </td></tr>
    <tr><td class="paramname">highOp</td><td>High operator (LT/LTE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_opcodes_exception.html" title="An exception that is thrown when some unexpected error occurs in the hash table.">BadOpcodesException</a></td><td>If lowOp and highOp do not contain one of their their expected values </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_bad_scanrange_exception.html" title="An exception that is thrown when some unexpected error occurs in the hash table.">BadScanrangeException</a></td><td>If lowVal &gt; highval </td></tr>
    <tr><td class="paramname"><a class="el" href="classbadgerdb_1_1_no_such_key_found_exception.html" title="An exception that is thrown when a file operation is requested for a filename that doesn&#39;t exist.">NoSuchKeyFoundException</a></td><td>If there is no key in the B+ tree that satisfies the scan criteria. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="btree_8cpp_source.html#l00131">131</a> of file <a class="el" href="btree_8cpp_source.html">btree.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;{</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="keywordflow">if</span>(lowValParm &gt; highValParm) <span class="keywordflow">throw</span> BadScanrangeException();</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160; </div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; </div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">/*</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">  This method is used to begin a “filtered scan” of the index. For example, if the</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">  method is called using arguments (1,GT,100,LTE), then the scan should seek all</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">  entries greater than 1 and less than or equal to 100.</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  </div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/mnt/c/Users/Jerem/Desktop/proj3/src/<a class="el" href="btree_8h_source.html">btree.h</a></li>
<li>/mnt/c/Users/Jerem/Desktop/proj3/src/<a class="el" href="btree_8cpp_source.html">btree.cpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassbadgerdb_1_1_b_tree_index_html_a13e41d11eeaf3d28fc9748edec50ac98"><div class="ttname"><a href="classbadgerdb_1_1_b_tree_index.html#a13e41d11eeaf3d28fc9748edec50ac98">badgerdb::BTreeIndex::startScan</a></div><div class="ttdeci">void startScan(const void *lowVal, const Operator lowOp, const void *highVal, const Operator highOp)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8cpp_source.html#l00131">btree.cpp:131</a></div></div>
<div class="ttc" id="aclassbadgerdb_1_1_buf_mgr_html_acc61d1985720411ebb76e70f702827d3"><div class="ttname"><a href="classbadgerdb_1_1_buf_mgr.html#acc61d1985720411ebb76e70f702827d3">badgerdb::BufMgr::flushFile</a></div><div class="ttdeci">void flushFile(const File *file)</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8cpp_source.html#l00190">buffer.cpp:190</a></div></div>
<div class="ttc" id="aclassbadgerdb_1_1_b_tree_index_html_a70a051c8c03a5cc0ca9451bdd56ddb65"><div class="ttname"><a href="classbadgerdb_1_1_b_tree_index.html#a70a051c8c03a5cc0ca9451bdd56ddb65">badgerdb::BTreeIndex::insertEntry</a></div><div class="ttdeci">void insertEntry(const void *key, const RecordId rid)</div><div class="ttdef"><b>Definition:</b> <a href="btree_8cpp_source.html#l00113">btree.cpp:113</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
